#!/bin/bash

<< '////'
TODO:
 
 - automatic association of files
 
 - add fit function for low temperatures
 
 - add append function
 
 - add Debye temperature

////

homedir=. ; 

HELP=$(
cat <<- EOF

--------------------------------------------------------------------------------
                                  HEATh
--------------------------------------------------------------------------------

author:       https://github.com/axkf
dependencies: bash 4.4.20(1) , GNU awk 4.2.1 , Gnuplot 5.2
version:      2024-04-27


  HEATh is a tool to calculate Gibbs free energies of solid phases from phonopy
  thermal_properties files. It can be used to get values for specific temperatures 
  and pressures or output formula strings, that can be utilized as input for 
  other programs.


------------------------------ GENERAL USAGE -----------------------------------

    path/HEATh [-options] [-fT/fO/fP files]

------------------------------ FILES / INPUT -----------------------------------

  
  Unfortunately there is no file, that contains all necessary information. Three
  files are therefore needed per structure: The OUTCAR file, which contains the
  energy and structure, the thermal_properties.yaml file generated by phonopy, and
  optionally a phonopy.yaml file, which lists structure and space group. The latter
  might be useful to distinguish compounds with like composition. Only inputting
  one or two file types is possible, even though the results will be incomplete.
  
  Since especially the thermal_properties files lack structural information, 
  manual assignment is required for the script to work properly. The files there-
  fore need to be input as three space-separated strings. The file type is
  then indicated by a prefix: -fO (OUTCAR files), -fT (thermal_properties.yaml 
  files) and -fP (phonopy.yaml files). While the file names do not matter, their
  number and ordering needs to be the same (or zero).
  
  Example:
  
    -fO OUTCAR1 OUTCAR2 -fT THERM1.yaml THERM2.yaml -fP ...
  

-------------------------- OPTIONS AND PRINTING --------------------------------


  As for the files, the number of parameters in the options below need to match
  the number of files. In case of only one parameter being given, it will be used 
  for all files. If no parameter is defined, the script will skip all related 
  calculations. The following parameter options are available:


TEMPERATURE:

  The calculation temperature is defined (in Kelvin) using the -T modifier. Using
  another separator, it is possible to define temperature lists for specific files.
  In this case, each of the calculations will be treated like a separate file (each 
  calculation receives its own array index to access the values).

  Example (4 structures):

    -T 298.15 300#400#500 412,412.1,412.2,412.3,412.4 666

  This performs single calculations for the structures 1 and 4 (298.15 K and 666 K) 
  and serial calculations for the structures 2 (300 K, 400 K, 500 K) and 3 (412 K, 
  412.1 K, 412.2 K, 412.3 K, 412.4 K).


CORRECTIONS:

  HEATh offers the option to modify enthalpy (-cH), entropy (-cS) and/or Gibbs 
  free energy (-cG) by inputting mathematical terms. This can be used to convert 
  units or add extra terms. The terms should be quoted to prevent shell inter-
  ference. Since the assignment rules described above apply here as well, no spaces 
  are allowed within terms. Make sure there is an operator connecting the 
  correction to the original expression and to include unit conversions factors. 
  All operators implemented in GNU awk as well as some fundamental constants (see 
  chapter EXPORT) can be used.

  Example (3 structures):

    -cG "-R*T*log(3) *2+12.3456 /1000."


FIT PARAMETERS:

  To obtain a continuous representation of the phonopy values, a fit of the heat 
  capacity is conducted using the shomate equation:

    Cp(T) = a0 + a1*T + a2/2*T^2 + a3/3*T^3 + a4/4*T^4 - a5/T^2

  Enthalpy and entropy are then derived by integration. To allow for a smooth 
  transition, a0 is constrained to reproduce the Cp value calculated by phonopy 
  at a specified temperature (analogously the constants a6 and a7 in the enthalpy-
  and entropy expressions are based on the corresponding phonopy values).

  The fit parameters allow for a costumization of the fit range, as well as the 
  fixed reference temperature. The latter is compared to the data points contained 
  in the thermal_properties.yaml file and will be adjusted to match the closest 
  point within range. If no reference point is specified, the data value closest 
  to 300K and within range will be used. Similarly the minimum temperature will 
  default to 100K, if it is undefined or lower, since the Shomate equation is not 
  valid for small temperatures. All points above the minimum temperature will be
  used for fitting, if no upper boundary is defined.

  All temperatures need to be given in Kelvin using the format 
  
    Tmin:Tref:Tmax 
  
  for each file individually or for all at once by only definig one set of fit 
  parameters. The following abbreviations are allowed:

    Tmin: = Tmin:: , :Tmax = ::Tmax , Tmin:Tmax = Tmin::Tmax , Tref = :Tref:

  Example (5 structures): 

    -f 222:456.7:1200 298.15 124: :312:999 265:789
 
  is equivalent to
  
    -f 222:456.7:1200 100:298.15: 124:300: 100:312:999 265:300:789

  provided, the specified reference temperatures do exist.


---------------------------------- OUTPUT --------------------------------------


PRINTING:

  Calculated values can be printed by calling the -p option. By default this prints  
  the sum formula, energy, zero-point energy, enthalpy change, evaluated enthalpy 
  correction and total enthalpy, entropy correction and total entropy, as well as
  the correction of the Gibbs free energy and its total value. All values are given
  in kJ/mol except for the entropy (J/mol/K). Please use the correction options, to 
  convert to another unit.
  
  Contents and format of the output table are freely customizable by specifying the 
  desired arrys (see EXPORT) and their format as a printf-string. For example
  
    -p '"%-10s %.2f\n" ${A_HTH_CMPND[$number]} ${A_HTH_VAL_energy[$number]}'
  
  prints the sum formulas, as well as the energies as floating point numbers with a 
  precision of two digits. Printing is done for the whole array ($number being the 
  counting variable). Please quote the format string as shown in the example. For 
  safety reasons any semicolon in the string will be deleted.


EXPORT:

  Using the shell utility "source" via
  
    source path/HEATh [-options] [-fT/fO/fP files]
  
  or
  
    . path/HEATh [-options] [-fT/fO/fP files]

  allows for direct access of all calculated values via indexed bash arrays.
  Accessible arrays include a list of the processed files and their indicies,

    A_HTH_INDEX_OUTCAR
    A_HTH_INDEX_PHONOPY
    A_HTH_INDEX_THERMAL_PROPERTIES
    A_HTH_FILES_OUTCAR
    A_HTH_FILES_PHONOPY
    A_HTH_FILES_THERMAL_PROPERTIES
  
  structure-related data, like the sum formula, the number of atoms and formula 
  units within the unit cell, the elements involved and their quantity, as well 
  as symmetry information

    A_HTH_CMPND
    A_HTH_ELEM
    A_HTH_ELEZ
    A_HTH_ATOMS_OUTCAR
    A_HTH_FUNITS_OUTCAR
    A_HTH_ATOMS_PHONOPY
    A_HTH_FUNITS_PHONOPY
    A_HTH_ATOMS
    A_HTH_FUNITS
    A_HTH_SYM
    A_HTH_SYSTEM
    A_HTH_SYSTEM_FILES

  Additionally, all calculated values, including the shomate parameters and the 
  fit error, are listed. 

    A_HTH_VAL_energy
    A_HTH_VAL_zpe
    A_HTH_VAL_a1
    A_HTH_VAL_a2
    A_HTH_VAL_a3
    A_HTH_VAL_a4
    A_HTH_VAL_a5
    A_HTH_VAL_a6
    A_HTH_VAL_a7
    A_HTH_VAL_err
    A_HTH_VAL_Cp_total
    A_HTH_VAL_H_diff
    A_HTH_VAL_H_total
    A_HTH_VAL_S_corr
    A_HTH_VAL_S_total
    A_HTH_VAL_G_corr
    A_HTH_VAL_G_total

  Formula strings are generated for all thermodynamic properties

    A_HTH_FML_Cp_total
    A_HTH_FML_H_diff
    A_HTH_FML_H_total
    A_HTH_FML_S_total
    A_HTH_FML_G_total

  which can be used for other calculations or plotting. Finally, some fundamental 
  constants are included as well:

    NA = 6.02214076E+23
    h  = 6.62607015E-34
    kB = 1.380649E-23
    R  = 8.31446261815324
    F  = 96485.64853321233100184
    u  = 1.6605390666050E-27

  These can also be used for corrections of the enthalpy, entropy or Gibbs free 
  energy.


CUSTOM ELEMENT ORDERING:

  Invoking the ordering option "-o" allows for a custom ordering of the sum formulas 
  and the related arrays A_HTH_ELEM and A_HTH_ELEZ, which contain information about 
  the contents of the unit cell. This might be useful for postprocessing the results.
  
  Elements or groups of elements (1-18,3d-6d,4f,5f) listed after the -o modifier will
  be ordered according to the list. The remaining elements within the group "X" or 
  within other groups are ordered according to IUPAC pseudo-electronegativity. In 
  case of conflicting groups/elements the first appearence of an element is decisive. 
  If not mentioned explicitly, "X" is appended to the end of the string (-o without 
  definition is therefore equivalent to -o "X").

  Example:

    -o "Cu 3d 11 Ag"

  is equivalent to

    -o "Cu Sc Ti V Cr Mn Fe Co Ni (Cu) Zn Rg Au Ag (Cu) (Ag) X"

  Elements in parantheses are ignored in this case due to doubling.

EOF
) ; 


help=$(
cat <<- EOF

--------------------------------------------------------------------------------
                                  HEATh
--------------------------------------------------------------------------------

General usage:

  path/HEATh [-options] [-fT/fO/fP files]
  
  -fO               VASP OUTCAR files
  
  -fT               PHONOPY thermal_properties.yaml files
  
  -fP               PHONOPY phonopy.yaml files

Calculation options and parameters:
  
  -T [value]        change temperature in Kelvin (default: 298.15 K), accepts lists
  
  -cH [term]        correction of the total enthalpy
  
  -cS [term]        correction of the total entropy
  
  -cG [term]        correction of the total Gibbs free energy
  
  -f [min:ref:max]  fit parameters

Printing:

  -p [string]       print, customizable by adding a printf-string
  
  -o [string]       custom element ordering, accepts single elements and groups 
                    (1-18,3d-5f,X)

Export:

  . path/HEATh [-options] [-fT/fO/fP files]
  
 available arrays:
  
  A_HTH_INDEX_OUTCAR
  A_HTH_INDEX_PHONOPY
  A_HTH_INDEX_THERMAL_PROPERTIES
  A_HTH_FILES_OUTCAR
  A_HTH_FILES_PHONOPY
  A_HTH_FILES_THERMAL_PROPERTIES

  A_HTH_CMPND
  A_HTH_ELEM
  A_HTH_ELEZ
  A_HTH_ATOMS_OUTCAR
  A_HTH_FUNITS_OUTCAR
  A_HTH_ATOMS_PHONOPY
  A_HTH_FUNITS_PHONOPY
  A_HTH_ATOMS
  A_HTH_FUNITS
  A_HTH_SYM
  A_HTH_SYSTEM
  A_HTH_SYSTEM_FILES

  A_HTH_VAL_energy
  A_HTH_VAL_zpe
  A_HTH_VAL_a1
  A_HTH_VAL_a2
  A_HTH_VAL_a3
  A_HTH_VAL_a4
  A_HTH_VAL_a5
  A_HTH_VAL_a6
  A_HTH_VAL_a7
  A_HTH_VAL_err
  A_HTH_VAL_Cp_total
  A_HTH_VAL_H_diff
  A_HTH_VAL_H_total
  A_HTH_VAL_S_corr
  A_HTH_VAL_S_total
  A_HTH_VAL_G_corr
  A_HTH_VAL_G_total

  A_HTH_FML_Cp_total
  A_HTH_FML_H_diff
  A_HTH_FML_H_total
  A_HTH_FML_S_total
  A_HTH_FML_G_total

  NA = 6.02214076E+23
  h  = 6.62607015E-34
  kB = 1.380649E-23
  R  = 8.31446261815324
  F  = 96485.64853321233100184
  u  = 1.6605390666050E-27

EOF
) ; 


### INPUT
#enable extended globbing
shopt -s extglob
#reset
unset ARGS A_OPT lastopt lastarg ; 
#process ARGUMENTS
ARGS="${@}" ; 
for arg in $ARGS; do 
	#find options
	if [[ -z ${arg##-+([^[:digit:]])} ]]; then 
		lastopt="$arg" ; 
		declare -A A_OPT+=(["$arg"]="empty") ; 
	#find option arguments 
	else 
		lastarg=${A_OPT["$lastopt"]} ; 
		#replace empty
		if [[ -z ${lastarg#empty} ]]; then 
			declare -A A_OPT+=(["$lastopt"]="$arg") ; 
		#append
		else 
			declare -A A_OPT+=(["$lastopt"]+=" $arg") ; 
		fi ; 
	fi ; 
done ; 
unset lastopt lastarg ; 



# --help : HELP
if [[ -n ${A_OPT["--help"]} || -z $ARGS ]]; then 
	echo "$HELP" ; 
	echo "" ; 
	exit ; 
fi ; 


# -h : cheat sheet
if [[ -n ${A_OPT["-h"]} || -z $ARGS ]]; then 
	echo "$help" ; 
	echo "" ; 
	exit ; 
fi ; 




# FILES
# -fT : THERMAL_PROPERTIES.YAML
fTopts=${A_OPT["-fT"]} ; 
fTflag=$(set -f -- ${fTopts#empty} ; echo $#) ; 
unset FILES_t ; 
if [[ $fTflag -ne 0 ]]; then  
	for file in $fTopts; do 
		if [[ ! -f $file ]]; then 
			exit
		fi ; 
	done ; 
	FILES_t=$fTopts ; 
fi ; 

# -fO : OUTCAR
fOopts=${A_OPT["-fO"]} ; 
fOflag=$(set -f -- ${fOopts#empty} ; echo $#) ; 
unset FILES_e ; 
if [[ $fOflag -ne 0 ]]; then 
	for file in $fOopts; do 
		if [[ ! -f $file ]]; then 
			exit
		fi ; 
	done ; 
	FILES_e=$fOopts ; 
fi ; 

# -fP : PHONOPY.YAML
fPopts=${A_OPT["-fP"]} ; 
fPflag=$(set -f -- ${fPopts#empty} ; echo $#) ; 
unset FILES_p ; 
if [[ $fPflag -ne 0 ]]; then 
	for file in $fPopts; do 
		if [[ ! -f $file ]]; then 
			exit
		fi ; 
	done ; 
	FILES_p=$fPopts ; 
fi ; 

#find matching phonopy.yaml or phonopy_disp.yaml in same directory
if [[ -z $FILES_p ]]; then 
	for file in ${FILES_t:-$FILES_e}; do
		dir=$(dirname $file) ; 
		filename=${file##*/} ; 
		filename=${filename//therm*yaml/} ; 
		filename=${filename%[^A-Za-z0-9]} ; 
		
		#thermal_properties not renamed
		if [[ -z $filename && -f $dir/phonopy.yaml ]]; then
			FILES_p=$FILES_p""$dir/phonopy.yaml" " ; 
		elif [[ -z $filename && -f $dir/phonopy_disp.yaml ]]; then 
			FILES_p=$FILES_p""$dir/phonopy_disp.yaml" " ; 
		#thermal_properties renamed
		elif [[ -n $filename && -f $dir/$filename.phonopy.yaml ]]; then 
			FILES_p=$FILES_p""$dir/$filename.phonopy.yaml" " ; 
		elif [[ -n $filename && -f $dir/$filename.phonopy_disp.yaml ]]; then 
			FILES_p=$FILES_p""$dir/$filename.phonopy_disp.yaml" " ; 
		#thermal_properties renamed, phonopy.yaml/phonopy_disp.yaml not renamed, no other structure in directory
		elif [[ -n $filename && ! -f $dir/$filename.phonopy.yaml && ! -f $dir/$filename.phonopy_disp.yaml ]]; then
			samedir=$(find $dir -regex ".*therm.*yaml" -not -regex ".*$filename.*") ; 
			if [[ -z $samedir && -f $dir/phonopy.yaml ]]; then 
				FILES_p=$FILES_p""$dir/phonopy.yaml" " ; 
			elif [[ -z $samedir && -f $dir/phonopy_disp.yaml ]]; then 
				FILES_p=$FILES_p""$dir/phonopy_disp.yaml" " ; 
			fi ; 
		fi ; 
	done ; 
fi ; 
fPflag=$(set -f -- $FILES_p ; echo $#) ; 

# test file consistency
# if [[ -z ${FILES_e:-${FILES_t:-$FILES_p}} ]]; then 
if [[ -z $FILES_t && -z $FILES_p && -z $FILES_e ]]; then 
	exit ; 
elif [[ -n $FILES_t && -n $FILES_p && $fTflag -ne $fPflag ]]; then 
	exit ; 
elif [[ -n $FILES_t && -n $FILES_e && $fTflag -ne $fOflag ]]; then 
	exit ; 
elif [[ -n $FILES_e && -n $FILES_p && $fOflag -ne $fPflag ]]; then 
	exit ; 
fi ; 



# CORRECTIONS
# -cH : H-CORRECTION
cHopts=${A_OPT["-cH"]} ; 
cHflag=$(set -f -- ${cHopts#empty} ; echo $#) ; 
unset cH ; 
if [[ $cHflag -eq 1 ]]; then 
	for file in ${FILES_e:-${FILES_t:-$FILES_p}}; do 
		cH=$cH""$cHopts" " ; 
	done ; 
elif [[ $cHflag -gt 1 && ($cHflag -eq $fTflag || $cHflag -eq $fOflag) ]]; then 
	cH=$cHopts ; 
fi ; 

# -cS : S-CORRECTION
cSopts=${A_OPT["-cS"]} ; 
cSflag=$(set -f -- ${cSopts#empty} ; echo $#) ; 
unset cS ; 
if [[ $cSflag -eq 1 ]]; then 
	for file in ${FILES_e:-${FILES_t:-$FILES_p}}; do 
		cS=$cS""$cSopts" " ; 
	done ; 
elif [[ $cSflag -gt 1 && ($cSflag -eq $fTflag || $cSflag -eq $fOflag) ]]; then 
	cS=$cSopts ; 
fi ; 

# -cG : G-CORRECTION
cGopts=${A_OPT["-cG"]} ; 
cGflag=$(set -f -- ${cGopts#empty} ; echo $#) ; 
unset cG ; 
if [[ $cGflag -eq 1 ]]; then 
	for file in ${FILES_e:-${FILES_t:-$FILES_p}}; do 
		cG=$cG""$cGopts" " ; 
	done ; 
elif [[ $cGflag -gt 1 && ($cGflag -eq $fTflag || $cGflag -eq $fOflag) ]]; then 
	cG=$cGopts ; 
fi ; 



# FIT- & CALCULATION PARAMETERS
# -f : FIT PARAMETERS: Tmin:Tref:Tmax
fopts=${A_OPT["-f"]} ; 
fflag=$(set -f -- ${fopts#empty} ; echo $#) ; 
unset f ; 
# if [[ $fflag -eq 0 ]]; then 
	# for file in ${FILES_e:-${FILES_t:-$FILES_p}}; do 
		# f=$f": " ; 
	# done ; 
if [[ $fflag -eq 1 ]]; then 
	for file in ${FILES_e:-${FILES_t:-$FILES_p}}; do 
		f=$f""$fopts" " ; 
	done ; 
elif [[ $fflag -gt 1 && $fflag -eq $fTflag ]]; then 
	f=$fopts ; 
fi ; 
f=" "${f//+([^ 0-9eE.])/:}" " ; 

# -T : TEMPERATURE
Topts=${A_OPT["-T"]} ; 
Tflag=$(set -f -- ${Topts#empty} ; echo $#) ; 
unset T ; 
if [[ $Tflag -eq 1 ]]; then 
	for file in ${FILES_e:-${FILES_t:-$FILES_p}}; do
		T=$T""$Topts" " ; 
	done ; 
elif [[ $Tflag -gt 1 && ($Tflag -eq $fTflag || $Tflag -eq $fOflag) ]]; then 
	T=$Topts ; 
fi ; 

#duplicate files / Scorr.
if [[ -n $T ]]; then 
	tmp_T=$T ; 
	tmp_t=$FILES_t ; 
	tmp_p=$FILES_p ; 
	tmp_e=$FILES_e ; 
	tmp_cH=$cH ; 
	tmp_cS=$cS ; 
	tmp_cG=$cG ; 
	tmp_f=$f ; 
	unset T FILES_t FILES_p FILES_e cH cS cG f ; 
	i=0 ; 
	for T_i in $tmp_T; do 
		#ith file
		file_t=$(set -f -- $tmp_t ; shift $i ; echo $1) ; 
		file_p=$(set -f -- $tmp_p ; shift $i ; echo $1) ; 
		file_e=$(set -f -- $tmp_e ; shift $i ; echo $1) ; 
		Hcorr=$(set -f -- $tmp_cH ; shift $i ; echo $1) ; 
		Scorr=$(set -f -- $tmp_cS ; shift $i ; echo $1) ; 
		Gcorr=$(set -f -- $tmp_cG ; shift $i ; echo $1) ; 
		param=$(set -f -- $tmp_f ; shift $i ; echo $1) ; 
		
		#multiply
		for T_ii in ${T_i//[^ 0-9.eE+-]/ }; do 
			T=$T""$T_ii" " ; 
			FILES_t=$FILES_t""$file_t" " ; 
			FILES_p=$FILES_p""$file_p" " ; 
			FILES_e=$FILES_e""$file_e" " ; 
			cH=$cH""$Hcorr" " ; 
			cS=$cS""$Scorr" " ; 
			cG=$cG""$Gcorr" " ; 
			f=$f""$param" " ; 
		done ; 
		
		#count
		((i++)) ; 
	done ; 
fi ; 

#remove trailing spaces
T=${T%"${T##*[![:space:]]}"} ; 
FILES_t=${FILES_t%"${FILES_t##*[![:space:]]}"} ; 
FILES_p=${FILES_p%"${FILES_p##*[![:space:]]}"} ; 
FILES_e=${FILES_e%"${FILES_e##*[![:space:]]}"} ; 
cH=${cH%"${cH##*[![:space:]]}"} ; 
cS=${cS%"${cS##*[![:space:]]}"} ; 
cG=${cG%"${cG##*[![:space:]]}"} ; 
f=${f%"${f##*[![:space:]]}"} ; 



# OUTPUT OPTIONS
# -p : PRINT
popts=${A_OPT["-p"]} ; 
if [[ -z $popts ]]; then 
	pflag=0 ; 
	popts="" ; 
elif [[ -z ${popts#empty} ]]; then 
	pflag=1 ; 
	popts='"%-8s %16.8f %15.8f %15.8f %15.8f %16.8f %15.8f %15.8f %15.8f %16.8f\n" ${A_HTH_CMPND[$number]} ${A_HTH_VAL_energy[$number]} ${A_HTH_VAL_zpe[$number]} ${A_HTH_VAL_H_diff[$number]} ${A_HTH_VAL_H_corr[$number]} ${A_HTH_VAL_H_total[$number]} ${A_HTH_VAL_S_corr[$number]} ${A_HTH_VAL_S_total[$number]} ${A_HTH_VAL_G_corr[$number]} ${A_HTH_VAL_G_total[$number]}' ; 
else 
	pflag=1 ; 
fi ; 


# -a : APPEND
aopts=${A_OPT["-a"]} ; 
if [[ -z $aopts ]]; then 
	aflag=0 ; 
else 
	aflag=1 ; 
fi ; 


# -o : ORDER ELEMENTS
oopts=${A_OPT["-o"]} ; 
if [[ -z $oopts ]]; then 
	oflag=0 ; 
	PRIO="" ; 
elif [[ -z ${oopts#empty} ]]; then 
	oflag=1 ; 
	PRIO=X ; 
else 
	oflag=1 ; 
	PRIO=$oopts ; 
fi ; 

#add missing X-priority
if [[ -z ${PRIO//[^X]/} ]]; then 
	PRIO+=" X" ; 
fi ; 
unset oopts ; 




### FUNDAMENTAL CONSTANTS
NA=6.02214076E+23 ; 
h=6.62607015E-34 ; 
kB=1.380649E-23 ; 
R=8.31446261815324 ; 
F=96485.64853321233100184 ; 
u=1.6605390666050E-27 ; 
pi=3.141592653589793 ; 


#reset
if [[ $aflag -eq 0 ]]; then
	unset A_HTH_INDEX_OUTCAR A_HTH_INDEX_PHONOPY A_HTH_INDEX_THERMAL_PROPERTIES A_HTH_FILES_OUTCAR A_HTH_FILES_PHONOPY A_HTH_FILES_THERMAL_PROPERTIES ; 
	unset A_HTH_CMPND A_HTH_ELEM A_HTH_ELEZ A_HTH_ATOMS_OUTCAR A_HTH_FUNITS_OUTCAR A_HTH_ATOMS_PHONOPY A_HTH_FUNITS_PHONOPY A_HTH_ATOMS A_HTH_FUNITS A_HTH_SYM A_HTH_SYSTEM A_HTH_SYSTEM_FILES ; 
	unset A_HTH_PAR_T A_HTH_PAR_c A_HTH_PAR_C ; 
	unset A_HTH_VAL_energy A_HTH_VAL_zpe A_HTH_VAL_a1 A_HTH_VAL_a2 A_HTH_VAL_a3 A_HTH_VAL_a4 A_HTH_VAL_a5 A_HTH_VAL_a6 A_HTH_VAL_a7 A_HTH_VAL_err A_HTH_VAL_Cp_total A_HTH_VAL_H_diff A_HTH_VAL_H_corr A_HTH_VAL_H_total A_HTH_VAL_S_corr A_HTH_VAL_S_total A_HTH_VAL_G_corr A_HTH_VAL_G_total ; 
	unset A_HTH_FML_Cp_total A_HTH_FML_H_diff A_HTH_FML_H_total A_HTH_FML_S_total A_HTH_FML_G_total ; 
	unset A_HTH_DATA counter ; 
fi ; 



### PROCESS FILES
#OUTCAR files
unset A_HTH_VAL_energy ; 
if [[ -n $FILES_e ]]; then 
. <( gawk -v F="$F" -v PRIO="$PRIO" '
#switch array index and value
function array_invert(array_invert_ARRAY){ 
	if(isarray(array_invert_ARRAY)){
		for(number in array_invert_ARRAY){
			array_invert_ARRAY[array_invert_ARRAY[number]]=number ; 
			delete array_invert_ARRAY[number]
		}
	}
 } ; 
#reindex array with values from another array
function array_reindex(array_reindex_ARRAY,array_reindex_INDEX){ 
	if(!isarray(array_reindex_ARRAY) || !isarray(array_reindex_INDEX)){
		return
	} ; 
	
	for(number in array_reindex_ARRAY){
		array_reindex_ARRAY[array_reindex_INDEX[number]]=array_reindex_ARRAY[number] ; 
		delete array_reindex_ARRAY[number]
	}
 } ; 
#sort elements according to IUPAC order
function sort_elements(sort_elements_STRING_elem,sort_elements_STRING_prio,sort_elements_SPACER,save_procinfo_sorted_in,sort_elements_STRING_IUPAC,sort_elements_ARRAY_prio,sort_elements_ARRAY_residual,sort_elements_ARRAY_group,sort_elements_ARRAY_elem,sort_elements_STRING_result){ 
	#test variables
	if( !(typeof(sort_elements_STRING_elem)=="string" || typeof(sort_elements_STRING_elem)=="unassigned" || typeof(sort_elements_STRING_elem)=="untyped") ){
		return
	} ; 
	if( typeof(sort_elements_STRING_prio)=="array" || typeof(sort_elements_STRING_prio)=="bool" || typeof(sort_elements_STRING_prio)=="regexp"){
		return
	} ; 
	
	#store array sorting order
	save_procinfo_sorted_in=PROCINFO["sorted_in"] ; 
	PROCINFO["sorted_in"]="@unsorted" ; 
	
	#define groups of the periodic system
	sort_elements_ARRAY_residual[1]="Fr Cs Rb K Na Li " ; 
	sort_elements_ARRAY_residual[2]="Ra Ba Sr Ca Mg Be " ; 
	sort_elements_ARRAY_residual[3]="Ac La Y Sc " ; 
	sort_elements_ARRAY_residual[4]="Rf Hf Zr Ti " ; 
	sort_elements_ARRAY_residual[5]="Db Ta Nb V " ; 
	sort_elements_ARRAY_residual[6]="Sg W Mo Cr " ; 
	sort_elements_ARRAY_residual[7]="Bh Re Tc Mn " ; 
	sort_elements_ARRAY_residual[8]="Hs Os Ru Fe " ; 
	sort_elements_ARRAY_residual[9]="Mt Ir Rh Co " ; 
	sort_elements_ARRAY_residual[10]="Ds Pt Pd Ni " ; 
	sort_elements_ARRAY_residual[11]="Rg Au Ag Cu " ; 
	sort_elements_ARRAY_residual[12]="Cn Hg Cd Zn " ; 
	sort_elements_ARRAY_residual[13]="Nh Tl In Ga Al B " ; 
	sort_elements_ARRAY_residual[14]="Fl Pb Sn Ge Si cG " ; 
	sort_elements_ARRAY_residual[15]="Mc Bi Sb As P N " ; 
	sort_elements_ARRAY_residual[16]="Lv Po Te Se S O " ; 
	sort_elements_ARRAY_residual[17]="Ts At I Br Cl F " ; 
	sort_elements_ARRAY_residual[18]="Og Rn Xe Kr Ar Ne He " ; 
	sort_elements_ARRAY_residual[3"d"]="Sc Ti V Cr Mn Fe Co Ni Cu Zn " ; 
	sort_elements_ARRAY_residual[4"d"]="Y Zr Nb Mo Tc Ru Rh Pd Ag Cd " ; 
	sort_elements_ARRAY_residual[5"d"]="La Hf Ta W Re Os Ir Pt Au Hg " ; 
	sort_elements_ARRAY_residual[6"d"]="Ac Rf Db Sg Bh Hs Mt Ds Rg Cn " ; 
	sort_elements_ARRAY_residual[4"f"]="Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm Yb Lu " ; 
	sort_elements_ARRAY_residual[5"f"]="Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No Lr " ; 
	
	#define element order (IUPAC pseudo electronegativity)
	sort_elements_STRING_IUPAC="Og Rn Xe Kr Ar Ne He Fr Cs Rb K Na Li Ra Ba Sr Ca Mg Be Lr No Md Fm Es Cf Bk Cm Am Pu Np U Pa Th Ac Lu Yb Tm Er Ho Dy Tb Gd Eu Sm Pm Nd Pr Ce La Y Sc Rf Hf Zr Ti Db Ta Nb V Sg W Mo Cr Bh Re Tc Mn Hs Os Ru Fe Mt Ir Rh Co Ds Pt Pd Ni Rg Au Ag Cu Cn Hg Cd Zn Nh Tl In Ga Al B Fl Pb Sn Ge Si cG Mc Bi Sb As P N H Lv Po Te Se S O Ts At I Br Cl F " ; 
	
	#process priority string
	sort_elements_STRING_prio=sort_elements_STRING_prio" " ; 
	if(gsub("X ","X ",sort_elements_STRING_prio)==0){
		sort_elements_STRING_prio=sort_elements_STRING_prio"X "
	} ; 
	split(sort_elements_STRING_prio,sort_elements_ARRAY_prio," ") ; 
	
	#process specified groups: remove group elements from other groups and unspecified element list
	for(number in sort_elements_ARRAY_prio){
		if(sort_elements_ARRAY_prio[number] in sort_elements_ARRAY_residual){
			split(sort_elements_ARRAY_residual[sort_elements_ARRAY_prio[number]],sort_elements_ARRAY_group," ") ; 
			for(subnumber in sort_elements_ARRAY_group){
				#delete group elements from X
				gsub(sort_elements_ARRAY_group[subnumber]" ","",sort_elements_STRING_IUPAC) ; 
				
				#delete group elements from all other groups
				for(group in sort_elements_ARRAY_residual){
					if(group!=sort_elements_ARRAY_prio[number]){
						gsub(sort_elements_ARRAY_group[subnumber]" ","",sort_elements_ARRAY_residual[group])
					}
				}
			}
		}
	} ; 
	#process specified elements: remove specified elements from groups and unspecified element list
	for(number in sort_elements_ARRAY_prio){
		if( (sort_elements_ARRAY_prio[number]~/^[[:upper:]][[:lower:]]?$/) && !(sort_elements_ARRAY_prio[number] in sort_elements_ARRAY_residual) ){
			for(group in sort_elements_ARRAY_residual){
				gsub(sort_elements_ARRAY_prio[number]" ","",sort_elements_ARRAY_residual[group]) ; 
				gsub(sort_elements_ARRAY_prio[number]" ","",sort_elements_STRING_IUPAC)
			}
		}
	} ; 
	#process specified groups: replace groups in prio by elements
	for(number in sort_elements_ARRAY_prio){
		if(sort_elements_ARRAY_prio[number] in sort_elements_ARRAY_residual){
			sort_elements_ARRAY_prio[number]=sort_elements_ARRAY_residual[sort_elements_ARRAY_prio[number]]
		}
	} ; 
	#reassemble priority string
	sort_elements_STRING_result="" ; 
	for(number in sort_elements_ARRAY_prio){
		sort_elements_STRING_result=sort_elements_STRING_result""sort_elements_ARRAY_prio[number]" "
	} ; 
	sub("X ",sort_elements_STRING_IUPAC,sort_elements_STRING_result) ; 
	split(sort_elements_STRING_result,sort_elements_ARRAY_prio," ") ; 
	array_invert(sort_elements_ARRAY_prio) ; 
	
	#process element string
	if(sort_elements_STRING_elem!=""){
		split(sort_elements_STRING_elem,sort_elements_ARRAY_elem," ") ; 
		
		#sort elements
		for(number in sort_elements_ARRAY_elem){
			sort_elements_ARRAY_elem[sort_elements_ARRAY_elem[number]]=sort_elements_ARRAY_prio[sort_elements_ARRAY_elem[number]] ; 
			delete sort_elements_ARRAY_elem[number] ; 
		} ; 
		asorti(sort_elements_ARRAY_elem,sort_elements_ARRAY_elem,"@val_num_asc") ; 
		
		#reassemble element string
		sort_elements_STRING_result="" ; 
		for(number in sort_elements_ARRAY_elem){
			sort_elements_STRING_result=sort_elements_STRING_result""sort_elements_ARRAY_elem[number]" "
		}
	} ; 
	
	#restore array sorting order
	PROCINFO["sorted_in"]=save_procinfo_sorted_in ; 
	
	#return results
	return sort_elements_STRING_result
 } ; 
#find common divisors
function math_divisors(math_divisors_INPUT,math_divisors_SPACER,math_divisors_NUMBERS,math_divisors_ITERATE,math_divisors_MIRROR,math_divisors_DIVISORS,math_divisors_OUTPUT){ 
	#prepare array from string of numbers
	split(math_divisors_INPUT,math_divisors_NUMBERS," ") ; 
	
	#find all divisorss
	for(number in math_divisors_NUMBERS){
		math_divisors_ITERATE=sqrt(math_divisors_NUMBERS[number]) ; 
		for(subnumber=1;subnumber<=math_divisors_ITERATE;subnumber++){
			math_divisors_MIRROR=math_divisors_NUMBERS[number]/subnumber ; 
			if(gsub(/\./,"",math_divisors_MIRROR)!=1){
				math_divisors_DIVISORS[subnumber]=math_divisors_DIVISORS[subnumber]+1 ; 
				if(math_divisors_MIRROR!=subnumber){
					math_divisors_DIVISORS[math_divisors_MIRROR]=math_divisors_DIVISORS[math_divisors_MIRROR]+1
				}
			}
		}
	} ; 
	
	#find common divisorss
	for(div in math_divisors_DIVISORS){
		if(math_divisors_DIVISORS[div]<length(math_divisors_NUMBERS)){
			delete math_divisors_DIVISORS[div]
		}
	} ; 
	asorti(math_divisors_DIVISORS,math_divisors_DIVISORS,"@ind_num_desc") ; 
	
	#assemble output
	math_divisors_OUTPUT="" ; 
	for(number in math_divisors_DIVISORS){
		math_divisors_OUTPUT=math_divisors_OUTPUT""math_divisors_DIVISORS[number]" "
	} ; 	
	return math_divisors_OUTPUT
 } ; 

BEGIN{ 
	file=0
 }
 
BEGINFILE{
	line="" ; 
	ELEM="" ; 
	ELEZ="" ; 
	ATOMS="" ; 
	FUNITS=1 ; 
	CMPD="" ; 
	ENERGY="" ; 	
 }

/VRHFIN/{gsub(/:.+$/,"") ; gsub(/^.+=/,"") ; ELEM=ELEM""$0" "} 
/ions per type/{ sub(/[^0-9]+/,"",$0) ; ELEZ=$0 }
{ if(/FREE ENERGIE OF THE ION-ELECTRON SYSTEM/ && line==""){line=FNR} } 
	FNR==line+4 { if(line!=""){ENERGY=$NF}
 }

ENDFILE{ 
	split(ELEM,a_ELEM," ") ; 
	split(ELEZ,a_ELEZ," ") ; 
	for(number in a_ELEZ){
		ATOMS+=a_ELEZ[number] ; 
	} ; 
	
	#re-index arrays
	array_reindex(a_ELEZ,a_ELEM) ; 
	delete a_ELEM ; 
	
	#sort elements
	ELEM=sort_elements(ELEM,PRIO)
	split(ELEM,a_SORT," ") ; 
	
	#formula units from biggest common divisor
	FUNITS=math_divisors(ELEZ) ; 
	gsub(/ .*/,"",FUNITS) ; 
	
	ELEZ="" ; 
	#compound variants
	for(number in a_SORT){
		if(a_ELEZ[a_SORT[number]]/FUNITS>1){
			CMPD=CMPD""a_SORT[number]""a_ELEZ[a_SORT[number]]/FUNITS
		}
		else{
			CMPD=CMPD""a_SORT[number]
		} ; 
		ELEZ=ELEZ""a_ELEZ[a_SORT[number]]/FUNITS" "
	} ; 
	
	#energy per formula unit in kJ/mol
	ENERGY=ENERGY/FUNITS * (F/1000) ; 
	
	#export variables
	print "A_HTH_CMPND+=(\""CMPD"\") ; A_HTH_ELEM+=(\""ELEM"\") ; A_HTH_ELEZ+=(\""ELEZ"\") ; A_HTH_ATOMS_OUTCAR+=(\""ATOMS"\") ; A_HTH_FUNITS_OUTCAR+=(\""FUNITS"\") ; A_HTH_VAL_energy+=(\""sprintf("%.20f",ENERGY)"\") ; A_HTH_FILES_OUTCAR+=(\""FILENAME"\") ; declare -A A_HTH_INDEX_OUTCAR+=([\""FILENAME"\"]=\""file"\") ; " ; 
	
	file+=1
 }
' $FILES_e ) ; 
else
	for file in ${FILES_t:-$FILES_p}; do 
		A_HTH_ATOMS_OUTCAR+=("") ; 
		A_HTH_FUNITS_OUTCAR+=("") ; 
		A_HTH_VAL_energy+=("") ; 
		A_HTH_FILES_OUTCAR+=("") ; 
	done ; 
fi ; 

# number=0 ; 
# for file in ${FILES_t:-$FILES_p}; do 
	# #test energy
	# if [[ -z ${A_HTH_VAL_energy[$number]} ]]; then 
		# A_HTH_VAL_energy[$number]=0 ; 
	# fi ; 
	# ((number++)) ; 
# done ; 


#phonopy.yaml / phonopy_disp.yaml
if [[ -n $FILES_p ]]; then 
. <( gawk -v fOflag="$fOflag" -v PRIO="$PRIO" '
function array_invert(array_invert_ARRAY){ 
	if(isarray(array_invert_ARRAY)){
		for(number in array_invert_ARRAY){
			array_invert_ARRAY[array_invert_ARRAY[number]]=number ; 
			delete array_invert_ARRAY[number]
		}
	}
 } ; 
#reindex array with values from another array
function array_reindex(array_reindex_ARRAY,array_reindex_INDEX){ 
	if(!isarray(array_reindex_ARRAY) || !isarray(array_reindex_INDEX)){
		return
	} ; 
	
	for(number in array_reindex_ARRAY){
		array_reindex_ARRAY[array_reindex_INDEX[number]]=array_reindex_ARRAY[number] ; 
		delete array_reindex_ARRAY[number]
	}
 } ; 
#sort elements according to IUPAC order
function sort_elements(sort_elements_STRING_elem,sort_elements_STRING_prio,sort_elements_SPACER,save_procinfo_sorted_in,sort_elements_STRING_IUPAC,sort_elements_ARRAY_prio,sort_elements_ARRAY_residual,sort_elements_ARRAY_group,sort_elements_ARRAY_elem,sort_elements_STRING_result){ 
	#test variables
	if( !(typeof(sort_elements_STRING_elem)=="string" || typeof(sort_elements_STRING_elem)=="unassigned" || typeof(sort_elements_STRING_elem)=="untyped") ){
		return
	} ; 
	if( typeof(sort_elements_STRING_prio)=="array" || typeof(sort_elements_STRING_prio)=="bool" || typeof(sort_elements_STRING_prio)=="regexp"){
		return
	} ; 
	
	#store array sorting order
	save_procinfo_sorted_in=PROCINFO["sorted_in"] ; 
	PROCINFO["sorted_in"]="@unsorted" ; 
	
	#define groups of the periodic system
	sort_elements_ARRAY_residual[1]="Fr Cs Rb K Na Li " ; 
	sort_elements_ARRAY_residual[2]="Ra Ba Sr Ca Mg Be " ; 
	sort_elements_ARRAY_residual[3]="Ac La Y Sc " ; 
	sort_elements_ARRAY_residual[4]="Rf Hf Zr Ti " ; 
	sort_elements_ARRAY_residual[5]="Db Ta Nb V " ; 
	sort_elements_ARRAY_residual[6]="Sg W Mo Cr " ; 
	sort_elements_ARRAY_residual[7]="Bh Re Tc Mn " ; 
	sort_elements_ARRAY_residual[8]="Hs Os Ru Fe " ; 
	sort_elements_ARRAY_residual[9]="Mt Ir Rh Co " ; 
	sort_elements_ARRAY_residual[10]="Ds Pt Pd Ni " ; 
	sort_elements_ARRAY_residual[11]="Rg Au Ag Cu " ; 
	sort_elements_ARRAY_residual[12]="Cn Hg Cd Zn " ; 
	sort_elements_ARRAY_residual[13]="Nh Tl In Ga Al B " ; 
	sort_elements_ARRAY_residual[14]="Fl Pb Sn Ge Si cG " ; 
	sort_elements_ARRAY_residual[15]="Mc Bi Sb As P N " ; 
	sort_elements_ARRAY_residual[16]="Lv Po Te Se S O " ; 
	sort_elements_ARRAY_residual[17]="Ts At I Br Cl F " ; 
	sort_elements_ARRAY_residual[18]="Og Rn Xe Kr Ar Ne He " ; 
	sort_elements_ARRAY_residual[3"d"]="Sc Ti V Cr Mn Fe Co Ni Cu Zn " ; 
	sort_elements_ARRAY_residual[4"d"]="Y Zr Nb Mo Tc Ru Rh Pd Ag Cd " ; 
	sort_elements_ARRAY_residual[5"d"]="La Hf Ta W Re Os Ir Pt Au Hg " ; 
	sort_elements_ARRAY_residual[6"d"]="Ac Rf Db Sg Bh Hs Mt Ds Rg Cn " ; 
	sort_elements_ARRAY_residual[4"f"]="Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm Yb Lu " ; 
	sort_elements_ARRAY_residual[5"f"]="Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No Lr " ; 
	
	#define element order (IUPAC pseudo electronegativity)
	sort_elements_STRING_IUPAC="Og Rn Xe Kr Ar Ne He Fr Cs Rb K Na Li Ra Ba Sr Ca Mg Be Lr No Md Fm Es Cf Bk Cm Am Pu Np U Pa Th Ac Lu Yb Tm Er Ho Dy Tb Gd Eu Sm Pm Nd Pr Ce La Y Sc Rf Hf Zr Ti Db Ta Nb V Sg W Mo Cr Bh Re Tc Mn Hs Os Ru Fe Mt Ir Rh Co Ds Pt Pd Ni Rg Au Ag Cu Cn Hg Cd Zn Nh Tl In Ga Al B Fl Pb Sn Ge Si cG Mc Bi Sb As P N H Lv Po Te Se S O Ts At I Br Cl F " ; 
	
	#process priority string
	sort_elements_STRING_prio=sort_elements_STRING_prio" " ; 
	if(gsub("X ","X ",sort_elements_STRING_prio)==0){
		sort_elements_STRING_prio=sort_elements_STRING_prio"X "
	} ; 
	split(sort_elements_STRING_prio,sort_elements_ARRAY_prio," ") ; 
	
	#process specified groups: remove group elements from other groups and unspecified element list
	for(number in sort_elements_ARRAY_prio){
		if(sort_elements_ARRAY_prio[number] in sort_elements_ARRAY_residual){
			split(sort_elements_ARRAY_residual[sort_elements_ARRAY_prio[number]],sort_elements_ARRAY_group," ") ; 
			for(subnumber in sort_elements_ARRAY_group){
				#delete group elements from X
				gsub(sort_elements_ARRAY_group[subnumber]" ","",sort_elements_STRING_IUPAC) ; 
				
				#delete group elements from all other groups
				for(group in sort_elements_ARRAY_residual){
					if(group!=sort_elements_ARRAY_prio[number]){
						gsub(sort_elements_ARRAY_group[subnumber]" ","",sort_elements_ARRAY_residual[group])
					}
				}
			}
		}
	} ; 
	#process specified elements: remove specified elements from groups and unspecified element list
	for(number in sort_elements_ARRAY_prio){
		if( (sort_elements_ARRAY_prio[number]~/^[[:upper:]][[:lower:]]?$/) && !(sort_elements_ARRAY_prio[number] in sort_elements_ARRAY_residual) ){
			for(group in sort_elements_ARRAY_residual){
				gsub(sort_elements_ARRAY_prio[number]" ","",sort_elements_ARRAY_residual[group]) ; 
				gsub(sort_elements_ARRAY_prio[number]" ","",sort_elements_STRING_IUPAC)
			}
		}
	} ; 
	#process specified groups: replace groups in prio by elements
	for(number in sort_elements_ARRAY_prio){
		if(sort_elements_ARRAY_prio[number] in sort_elements_ARRAY_residual){
			sort_elements_ARRAY_prio[number]=sort_elements_ARRAY_residual[sort_elements_ARRAY_prio[number]]
		}
	} ; 
	#reassemble priority string
	sort_elements_STRING_result="" ; 
	for(number in sort_elements_ARRAY_prio){
		sort_elements_STRING_result=sort_elements_STRING_result""sort_elements_ARRAY_prio[number]" "
	} ; 
	sub("X ",sort_elements_STRING_IUPAC,sort_elements_STRING_result) ; 
	split(sort_elements_STRING_result,sort_elements_ARRAY_prio," ") ; 
	array_invert(sort_elements_ARRAY_prio) ; 
	
	#process element string
	if(sort_elements_STRING_elem!=""){
		split(sort_elements_STRING_elem,sort_elements_ARRAY_elem," ") ; 
		
		#sort elements
		for(number in sort_elements_ARRAY_elem){
			sort_elements_ARRAY_elem[sort_elements_ARRAY_elem[number]]=sort_elements_ARRAY_prio[sort_elements_ARRAY_elem[number]] ; 
			delete sort_elements_ARRAY_elem[number] ; 
		} ; 
		asorti(sort_elements_ARRAY_elem,sort_elements_ARRAY_elem,"@val_num_asc") ; 
		
		#reassemble element string
		sort_elements_STRING_result="" ; 
		for(number in sort_elements_ARRAY_elem){
			sort_elements_STRING_result=sort_elements_STRING_result""sort_elements_ARRAY_elem[number]" "
		}
	} ; 
	
	#restore array sorting order
	PROCINFO["sorted_in"]=save_procinfo_sorted_in ; 
	
	#return results
	return sort_elements_STRING_result
 } ; 
#find common divisors
function math_divisors(math_divisors_INPUT,math_divisors_SPACER,math_divisors_NUMBERS,math_divisors_ITERATE,math_divisors_MIRROR,math_divisors_DIVISORS,math_divisors_OUTPUT){ 
	#prepare array from string of numbers
	split(math_divisors_INPUT,math_divisors_NUMBERS," ") ; 
	
	#find all divisorss
	for(number in math_divisors_NUMBERS){
		math_divisors_ITERATE=sqrt(math_divisors_NUMBERS[number]) ; 
		for(subnumber=1;subnumber<=math_divisors_ITERATE;subnumber++){
			math_divisors_MIRROR=math_divisors_NUMBERS[number]/subnumber ; 
			if(gsub(/\./,"",math_divisors_MIRROR)!=1){
				math_divisors_DIVISORS[subnumber]=math_divisors_DIVISORS[subnumber]+1 ; 
				if(math_divisors_MIRROR!=subnumber){
					math_divisors_DIVISORS[math_divisors_MIRROR]=math_divisors_DIVISORS[math_divisors_MIRROR]+1
				}
			}
		}
	} ; 
	
	#find common divisorss
	for(div in math_divisors_DIVISORS){
		if(math_divisors_DIVISORS[div]<length(math_divisors_NUMBERS)){
			delete math_divisors_DIVISORS[div]
		}
	} ; 
	asorti(math_divisors_DIVISORS,math_divisors_DIVISORS,"@ind_num_desc") ; 
	
	#assemble output
	math_divisors_OUTPUT="" ; 
	for(number in math_divisors_DIVISORS){
		math_divisors_OUTPUT=math_divisors_OUTPUT""math_divisors_DIVISORS[number]" "
	} ; 	
	return math_divisors_OUTPUT
 } ; 
 
BEGIN{ 
	file=0 ; 
 }
BEGINFILE{ 
	ELEM="" ; 
	
	uflag="" ; 
	ELEZ="" ; 
	delete a_ELEZ ; 
	ATOMS="" ; 
	
	CMPD="" ; 
	
	symline="" ; 
	SYM=""
 } ; 
 
/atom_name:/{ELEM=$0 ; gsub(/^[^"]+"||"$/,"",ELEM)} ; 
/unit_cell/{uflag=1} /^$/{uflag=0} uflag{ 
	if(uflag!="" && /- symbol:/){
		elem=$0 ; gsub(/  - symbol: ||\s+#.+/,"",elem) ; 
		a_ELEZ[elem]=a_ELEZ[elem]+1 ; 
		ATOMS+=1 ; 
	} 
}
/space_group:/{ symline=FNR }{ if(symline!="" && FNR==symline+1){SYM=$0 ; gsub(/^[^"]+"||"$/,"",SYM)} } ; 

ENDFILE{
	#formula units from biggest common divisor
	for(elem in a_ELEZ){
		ELEZ=ELEZ""a_ELEZ[elem]" "
	} ; 
	FUNITS=math_divisors(ELEZ) ; 
	gsub(/ .*/,"",FUNITS) ; 
	
	if(fOflag==0){
		ELEZ="" ; 
		for(elem in a_ELEZ){
			ELEZ=ELEZ""a_ELEZ[elem]/FUNITS" "
		} ; 
		
		#sort elements
		ELEM=sort_elements(ELEM,PRIO)
		split(ELEM,a_SORT," ") ; 
		
		#arrange file name
		for(number in a_SORT){
			if(a_ELEZ[a_SORT[number]]/FUNITS>1){
				CMPD=CMPD""a_SORT[number]""a_ELEZ[a_SORT[number]]/FUNITS
			}
			else{
				CMPD=CMPD""a_SORT[number]
			}
		} ; 
		
		#export structure variables
		print "A_HTH_CMPND+=(\""CMPD"\") ; A_HTH_ELEM+=(\""ELEM"\") ; A_HTH_ELEZ+=(\""ELEZ"\") ; "
	} ; 
	
	#export phonopy variables
	print "A_HTH_ATOMS_PHONOPY+=(\""ATOMS"\") ; A_HTH_FUNITS_PHONOPY+=(\""FUNITS"\") ; A_HTH_SYM+=(\""SYM"\") ; A_HTH_FILES_PHONOPY+=(\""FILENAME"\") ; declare -A A_HTH_INDEX_PHONOPY+=([\""FILENAME"\"]=\""file"\") ; " ; 
	
	file+=1
 }
' $FILES_p ) ; 
else
	for file in ${FILES_t:-$FILES_e}; do 
		A_HTH_ATOMS_PHONOPY+=("") ; 
		A_HTH_FUNITS_PHONOPY+=("") ; 
		A_HTH_SYM+=("") ; 
		A_HTH_FILES_PHONOPY+=("") ; 
	done ; 
fi ; 

#build system name and a reduced name for files
number=0 ; 
for file in ${FILES_e:-${FILES_t:-$FILES_p}}; do 
	if [[ -n ${A_HTH_SYM[$number]} && -n ${A_HTH_CMPND[$number]} ]]; then
		A_HTH_SYSTEM+=(${A_HTH_CMPND[$number]}"_"${A_HTH_SYM[$number]}) ; 
		A_HTH_SYSTEM_FILES+=(${A_HTH_CMPND[$number]}"_"${A_HTH_SYM[$number]//[^[:alnum:]-]/""}) ; 
	elif [[ -z ${A_HTH_SYM[$number]} && -n ${A_HTH_CMPND[$number]} ]]; then 
		A_HTH_SYSTEM+=(${A_HTH_CMPND[$number]}) ; 
		A_HTH_SYSTEM_FILES+=(${A_HTH_SYSTEM[$number]}) ; 
	else 
		A_HTH_SYSTEM[$number]=${file##*/} ; 
		A_HTH_SYSTEM[$number]=${A_HTH_SYSTEM[$number]%%.*([^.])} ; 
		A_HTH_SYSTEM[$number]=${A_HTH_SYSTEM[$number]//*(.)thermal_properties/} ; 
		A_HTH_SYSTEM[$number]=${A_HTH_SYSTEM[$number]#.} ; 
		if [[ -z ${A_HTH_SYSTEM[$number]} ]]; then 
			A_HTH_SYSTEM[$number]=$number
		fi ; 
		A_HTH_SYSTEM_FILES+=(${A_HTH_SYSTEM[$number]}) ; 
	fi ; 
	((number++)) ; 
done ; 


#thermal_properties.yaml
if [[ -n $FILES_t ]]; then 
. <( gawk -v ATOMS_OUTCAR="${A_HTH_ATOMS_OUTCAR[*]}" -v FUNITS_OUTCAR="${A_HTH_FUNITS_OUTCAR[*]}" -v ATOMS_PHONOPY="${A_HTH_ATOMS_PHONOPY[*]}" -v FUNITS_PHONOPY="${A_HTH_FUNITS_PHONOPY[*]}" '
BEGIN{ 
	file=0 ; 
	split(ATOMS_OUTCAR,a_ATOMS_OUTCAR," ") ; 
	split(ATOMS_PHONOPY,a_ATOMS_PHONOPY," ") ; 
	split(FUNITS_OUTCAR,a_FUNITS_OUTCAR," ") ; 
	split(FUNITS_PHONOPY,a_FUNITS_PHONOPY," ") ; 
	i=0
 } ; 

/natom: /{ 
	ATOMS_THERMAL=$0 ; gsub("[^0-9]","",ATOMS_THERMAL) ; 
	if(ATOMS_THERMAL==a_ATOMS_PHONOPY[file+1]){
		ATOMS=a_ATOMS_PHONOPY[file+1] ; 
		FUNITS=a_FUNITS_PHONOPY[file+1]
	}
	else if(ATOMS_THERMAL==a_ATOMS_OUTCAR[file+1]){
		ATOMS=a_ATOMS_OUTCAR[file+1] ; 
		FUNITS=a_FUNITS_OUTCAR[file+1]
	}
	else{
		ATOMS=ATOMS_THERMAL ; 
		FUNITS=1
	} ; 
 } ; 
/zero_point_energy:/{ZPE=$NF}
/- temperature:/{ i=FNR ; T[i]=$NF } 
	{ if( FNR==i+1 && i>0 ){F[i]=$NF/FUNITS} } ; 
	{ if( FNR==i+2 && i>0 ){S[i]=$NF/FUNITS} } ; 
	{ if( FNR==i+3 && i>0 ){cG[i]=$NF/FUNITS} } ; 
	{ if( FNR==i+4 && i>0 ){E[i]=$NF/FUNITS} }

ENDFILE{ 
	DATA="" ; 
	for(ind in T){
		DATA=sprintf("%s\n%7d %15.7f %15.7f %15.7f %15.7f",DATA,T[ind],F[ind],S[ind],cG[ind],E[ind]) ; 
	} ; 
	sub("\n","",DATA) ; 
	
	#export variables
	print "A_HTH_ATOMS+=(\""ATOMS"\") ; A_HTH_FUNITS+=(\""FUNITS"\") ; A_HTH_ATOMS_THERMAL_PROPERTIES+=(\""ATOMS_THERMAL"\") ; A_HTH_VAL_zpe+=(\""sprintf("%.7f",ZPE/FUNITS)"\") ; A_HTH_DATA+=(\""DATA"\") ; A_HTH_FILES_THERMAL_PROPERTIES+=(\""FILENAME"\") ; declare -A A_HTH_INDEX_THERMAL_PROPERTIES+=([\""FILENAME"\"]=\""file"\") ; " ; 
	
	#export data file
	#print "echo \""DATA"\" > $homedir/${A_HTH_SYSTEM_FILES["file"]}.data ; "
	
	file+=1
 }' $FILES_t ) ; 
else
	for file in ${FILES_e:-$FILES_p}; do 
		A_HTH_ATOMS+=("") ; 
		A_HTH_FUNITS+=("") ; 
		A_HTH_ATOMS_THERMAL_PROPERTIES+=("") ; 
		A_HTH_VAL_zpe+=( "" ) ; 
		A_HTH_DATA+=("") ; 
		A_HTH_FILES_THERMAL_PROPERTIES+=("") ; 
	done ; 
fi ; 

# number=0 ; 
# for file in ${FILES_e:-$FILES_p}; do 
	# #test energy
	# if [[ -z ${A_HTH_VAL_zpe[$number]} ]]; then 
		# A_HTH_VAL_zpe[$number]=0 ; 
	# fi ; 
	# ((number++)) ; 
# done ; 

unset DATA ; 
number=0 ; 
for file in $FILES_t; do 
	DATA=$(cat <<- EOF
		$DATA
		
		
		# ${A_HTH_SYSTEM[$number]}
		# T / K    F / [kJ/mol]   S / [J/mol/K]  Cp / [J/mol/K]    E / [kJ/mol]
		${A_HTH_DATA[$number]}
EOF
	) ; 
	((number++)) ; 
done ; 
DATA=${DATA##$'\n\n\n'} ; 


### CALCULATION
. <(gnuplot <<-EOF

set print "-" ; 
set fit quiet ; 
set fit logfile "/dev/null" ; 

# FUNDAMENTAL CONSTANTS
NA= $NA ; 
h = $h ; 
kB= $kB ; 
R = $R ; 
F = $F ; 
u = $u ; 

# FLAGS
fTflag=$fTflag ; 

# STRING VARIABLES
string_sys="${A_HTH_SYSTEM_FILES[*]}" ; 
string_E  ="${A_HTH_VAL_energy[*]}" ; 
string_zpe="${A_HTH_VAL_zpe[*]}" ; 
string_cH ="$cH" ; 
string_cS ="$cS" ; 
string_cG ="$cG" ; 
string_T  ="$T" ; 
string_fit="$f" ; 

# DATA
\$DATA << EOD
$DATA
EOD



# ITERATION
system_last="start" ; 
i=1 ; 
do for [system in string_sys]{
	# SYSTEM PARAMETERS
	T=word(string_T,i) ; 
	E=word(string_E,i) ; 
		E=strlen(E) > 0 ? E+0 : 0 ; 
	zpe=word(string_zpe,i) ; 
		zpe=strlen(zpe) > 0 ? zpe+0 : 0 ; 
	c_H=word(string_cH,i) ; 
	c_S=word(string_cS,i) ; 
	c_G=word(string_cG,i) ; 
	cmpnd=substr(system,1,strstrt(system,"_")-1) ; 
	param=word(string_fit,i) ; 
	
	
	if(fTflag && system ne system_last){
		# DECONCATENATE FIT PARAMETERS
		Tsep1=strstrt(param,":") ; 
			Tmin=Tsep1 > 1 ? substr(param,1,Tsep1-1) : "" ; 
		param=substr(param,Tsep1+1,-1) ; 
		
		Tsep2=strstrt(param,":") ; 
			Tref=Tsep2 > 1 ? substr(param,1,Tsep2-1) : "" ; 
		param=substr(param,Tsep2+1,-1) ; 
		
		Tsep3=strstrt(param,":") ; 
			Tmax=Tsep3 > 0 ? substr(param,1,Tsep3-1) : param ; 
		if(Tsep1==0 && Tsep2==0){Tref=Tmax ; Tmax=""} ; 
		
		# TEST FIT PARAMETERS & ALIGN WITH DATA
		Tmin=strlen(Tmin) > 0 && Tmin > 100 ? Tmin : "100" ; 
		Tmax=strlen(Tmax) == 0 || Tmax > 100 ? Tmax : "100" ; 
			if(strlen(Tmax) > 0 && Tmax < Tmin){swap=Tmin ; Tmin=Tmax ; Tmax=swap} ; 
		
		Tref=strlen(Tref) > 0 ? Tref : "300" ; 
		eval sprintf("STATS_records=0 ; T0=0 ; stats [%s:%s] \$DATA index i-1 using ( T0=abs(Tref-\$1) <= abs(Tref-T0) ? (Cp0=\$4 , H0=\$5 , S0=\$3 , \$1) : T0 , \$1 ):2 nooutput",Tmin,Tmax) ; 
			if(STATS_records < 4){ continue } ; 
			T0=T0 >= STATS_min_x ? T0 : STATS_min_x ; 
			T0=T0 <= STATS_max_x ? T0 : STATS_max_x ; 
		
		# FIT
		set dummy T ; 
		a2=a3=a4=a5 = 1 ; 
		Cp(T) = Cp0 + a2*(T-T0) + a3*(T**2-T0**2) + a4*(T**3-T0**3) - a5*((T**2+T0**2)/(T**2*T0**2)) ; 
		eval sprintf("fit [%s:%s] Cp(T) \$DATA index i-1 using 1:4 via a2,a3,a4,a5",Tmin,Tmax) ; 
		 a1   = Cp0 - a2*T0 - a3*T0**2 - a4*T0**3 - a5/T0**2 ; 

		 a6   = 1/2.*a2*T0**2 + 2/3.*a3*T0**3 + 3/4.*a4*T0**4 + 2*a5/T0 - Cp0*T0 + 1000*H0 ; 
		dH(T) = ( a1*T + 1/2.*a2*T**2 + 1/3.*a3*T**3 + 1/4.*a4*T**4 - a5/T + a6 )/1000. ; 

		 a7   = -Cp0*log(T0) - a2*T0*(1-log(T0)) - a3*T0**2*(1/2.-log(T0)) - a4*T0**3*(1/3.-log(T0)) + (a5/T0**2)*(1/2.+log(T0)) + S0 ; 
		dS(T) = a1*log(T) + a2*T + 1/2.*a3*T**2 + 1/3.*a4*T**3 - a5/(2*T**2) + a7 ; 
		
		
		# EXPORT FORMULAS
		print sprintf("A_HTH_VAL_a1+=( \"%.15E\" )",a1) ; 
		print sprintf("A_HTH_VAL_a2+=( \"%.15E\" )",a2) ; 
		print sprintf("A_HTH_VAL_a3+=( \"%.15E\" )",a3) ; 
		print sprintf("A_HTH_VAL_a4+=( \"%.15E\" )",a4) ; 
		print sprintf("A_HTH_VAL_a5+=( \"%.15E\" )",a5) ; 
		print sprintf("A_HTH_VAL_a6+=( \"%.15E\" )",a6) ; 
		print sprintf("A_HTH_VAL_a7+=( \"%.15E\" )",a7) ; 
		print sprintf("A_HTH_VAL_err+=( \"%.15E\" )",FIT_STDFIT) ; 
		
		print sprintf("A_HTH_FML_Cp_total+=( \"%.15E + %.15E*(T-%.15E) + %.15E*(T**2-%.15E**2) + %.15E*(T**3-%.15E**3) - %.15E*((T**2+%.15E**2)/(T**2*%.15E**2))\" ) ; ",Cp0,a2,T0,a3,T0,a4,T0,a5,T0,T0) ; 

		print sprintf("A_HTH_FML_H_total+=( \"(%.15E + (%.15E*T + 1/2.*%.15E*T**2 + 1/3.*%.15E*T**3 + 1/4.*%.15E*T**4 - %.15E/T + %.15E)/1000.)%s\" ) ; ",E,a1,a2,a3,a4,a5,a6,c_H) ; 
			print sprintf("A_HTH_FML_H_diff+=( \"(%.15E*T + 1/2.*%.15E*T**2 + 1/3.*%.15E*T**3 + 1/4.*%.15E*T**4 - %.15E/T + %.15E)/1000. - %.15E\" ) ; ",a1,a2,a3,a4,a5,a6,zpe) ; 
		
		print sprintf("A_HTH_FML_S_total+=( \"(%.15E*log(T) + %.15E*T + 1/2.*%.15E*T**2 + 1/3.*%.15E*T**3 - %.15E/(2*T**2) + %.15E)%s\" ) ; ",a1,a2,a3,a4,a5,a7,c_S) ; 
		
		print sprintf("A_HTH_FML_G_total+=( \"(%.15E + ((%.15E*T + 1/2.*%.15E*T**2 + 1/3.*%.15E*T**3 + 1/4.*%.15E*T**4 - %.15E/T + %.15E)/1000.)%s - T*((%.15E*log(T) + %.15E*T + 1/2.*%.15E*T**2 + 1/3.*%.15E*T**3 - %.15E/(2*T**2) + %.15E)%s)/1000.)%s\" ) ; ",E,a1,a2,a3,a4,a5,a6,c_H,a1,a2,a3,a4,a5,a7,c_S,c_G) ; 
	}
	else{ if(!fTflag){
		# NO FIT
		a1=a2=a3=a4=a5=a6=a7=Cp0=H0=S0=FIT_STDFIT = 0 ; T0=1 ; 
		Cp(T)=0 ; 
		dH(T)=0 ; 
		dS(T)=0 ; 
		
		
		# EXPORT FORMULAS
		print sprintf("A_HTH_VAL_a1+=( 0 )") ; 
		print sprintf("A_HTH_VAL_a2+=( 0 )") ; 
		print sprintf("A_HTH_VAL_a3+=( 0 )") ; 
		print sprintf("A_HTH_VAL_a4+=( 0 )") ; 
		print sprintf("A_HTH_VAL_a5+=( 0 )") ; 
		print sprintf("A_HTH_VAL_a6+=( 0 )") ; 
		print sprintf("A_HTH_VAL_a7+=( 0 )") ; 
		print sprintf("A_HTH_VAL_err+=( 0 )") ; 
		
		print sprintf("A_HTH_FML_Cp_total+=( 0 ) ; ") ; 

		print sprintf("A_HTH_FML_H_total+=( \"%.15E%s\" ) ; ",E,c_H) ; 
			print sprintf("A_HTH_FML_H_diff+=( 0 ) ; ") ; 
		
		print sprintf("A_HTH_FML_S_total+=( 0 ) ; ") ; 
		
		print sprintf("A_HTH_FML_G_total+=( \"(%.15E%s + T*(0%s)/1000.)%s\" ) ; ",E,c_H,c_S,c_G) ; 
	}} ; 
	system_last=system ; 
	
	
	
	# EVALUATE
	if(strlen(T)){
		# ENTHALPY
		eval sprintf("H_c=(E + dH(T))%s",c_H) ; 
		C_H = H_c - (E + dH(T)) ; 
		
		# ENTROPY
		eval sprintf("S_c=dS(T)%s",c_S) ; 
		C_S = S_c - dS(T) ; 
		
		# GIBBS FREE ENERGY
		G = H_c - T*S_c/1000. ; 
		eval sprintf("G_c=G%s",c_G) ; 
		C_G = G_c - G ; 
		
		
		# EXPORT VALUES
		print sprintf("A_HTH_VAL_Cp_total+=( \"%.20f\" )",Cp(T)) ; 
		
		print sprintf("A_HTH_VAL_H_total+=( \"%.20f\" )",H_c) ; 
			print sprintf("A_HTH_VAL_H_corr+=( \"%.20f\" )",C_H) ; 
			print sprintf("A_HTH_VAL_H_diff+=( \"%.20f\" )",dH(T)-zpe) ; 
		
		print sprintf("A_HTH_VAL_S_total+=( \"%.20f\" )",S_c) ; 
			print sprintf("A_HTH_VAL_S_corr+=( \"%.20f\" )",C_S) ; 
		
		print sprintf("A_HTH_VAL_G_total+=( \"%.20f\" )",G_c) ; 
			print sprintf("A_HTH_VAL_G_corr+=( \"%.20f\" )",C_G) ; 
	}
	else{
		# ENTHALPY
		eval sprintf("H_c=(E + zpe)%s",c_H) ; 
		C_H = H_c - (E + zpe) ; 
		
		# ENTROPY
		eval sprintf("S_c=0%s",c_S) ; 
		C_S = S_c ; 
		
		# GIBBS FREE ENERGY
		G = H_c ; 
		eval sprintf("G_c=G%s",c_G) ; 
		C_G = G_c - G ; 
		
		
		# EXPORT VALUES
		print sprintf("A_HTH_VAL_Cp_total+=( 0 )") ; 
		
		print sprintf("A_HTH_VAL_H_total+=( \"%.20f\" )",H_c) ; 
			print sprintf("A_HTH_VAL_H_corr+=( \"%.20f\" )",C_H) ; 
			print sprintf("A_HTH_VAL_H_diff+=( 0 )") ; 
		
		print sprintf("A_HTH_VAL_S_total+=( \"%.20f\" )",S_c) ; 
			print sprintf("A_HTH_VAL_S_corr+=( \"%.20f\" )",C_S) ; 
		
		print sprintf("A_HTH_VAL_G_total+=( \"%.20f\" )",G_c) ; 
			print sprintf("A_HTH_VAL_G_corr+=( \"%.20f\" )",C_G) ; 
	} ; 
	
	
	
	i=i+1 ; 
}
EOF
) ; 


#print
number=0 ; 
for file in ${FILES_e:-${FILES_t:-$FILES_p}}; do 
	if [[ $pflag -eq 1 ]]; then 
		eval printf ${popts//\;/} 2>/dev/null ; 
		((number++)) ; 
	fi ; 
done ; 





